{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/security/crypto.ts"],"sourcesContent":["/**\n * Security Core - Cryptographic Functions\n * Uses Web Crypto API for maximum security\n */\n\n// Constants\nconst JWT_ALGORITHM = \"HS256\"\nconst PIN_SALT_ROUNDS = 12\nconst TOKEN_EXPIRY = 15 * 60 * 1000 // 15 minutes for access token\nconst REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60 * 1000 // 7 days\n\n// Get secret key from environment\nfunction getSecretKey(): Uint8Array {\n  const secret = process.env.JWT_SECRET || process.env.AUTH_SECRET\n  if (!secret || secret.length < 32) {\n    throw new Error(\"JWT_SECRET must be at least 32 characters\")\n  }\n  return new TextEncoder().encode(secret)\n}\n\n// Generate cryptographically secure random bytes\nexport function generateSecureRandom(length: number): string {\n  const array = new Uint8Array(length)\n  crypto.getRandomValues(array)\n  return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\")\n}\n\n// Generate UUID v4\nexport function generateUUID(): string {\n  return crypto.randomUUID()\n}\n\n// HMAC-SHA256 signing\nasync function hmacSign(data: string, key: Uint8Array): Promise<string> {\n  const cryptoKey = await crypto.subtle.importKey(\n    \"raw\",\n    key,\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\"]\n  )\n  \n  const signature = await crypto.subtle.sign(\n    \"HMAC\",\n    cryptoKey,\n    new TextEncoder().encode(data)\n  )\n  \n  return btoa(String.fromCharCode(...new Uint8Array(signature)))\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=/g, \"\")\n}\n\n// HMAC-SHA256 verification\nasync function hmacVerify(data: string, signature: string, key: Uint8Array): Promise<boolean> {\n  const expectedSignature = await hmacSign(data, key)\n  \n  // Timing-safe comparison\n  if (signature.length !== expectedSignature.length) return false\n  \n  let result = 0\n  for (let i = 0; i < signature.length; i++) {\n    result |= signature.charCodeAt(i) ^ expectedSignature.charCodeAt(i)\n  }\n  \n  return result === 0\n}\n\n// Base64URL encode\nfunction base64UrlEncode(str: string): string {\n  return btoa(str)\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=/g, \"\")\n}\n\n// Base64URL decode\nfunction base64UrlDecode(str: string): string {\n  const padded = str + \"=\".repeat((4 - (str.length % 4)) % 4)\n  return atob(padded.replace(/-/g, \"+\").replace(/_/g, \"/\"))\n}\n\n// JWT Token Payload Interface\nexport interface JWTPayload {\n  sub: string // User ID\n  email: string\n  name?: string\n  iat: number // Issued at\n  exp: number // Expiration\n  jti: string // JWT ID (unique identifier)\n  type: \"access\" | \"refresh\"\n  fingerprint?: string // Device fingerprint\n}\n\n// Create JWT Token\nexport async function createJWT(\n  payload: Omit<JWTPayload, \"iat\" | \"exp\" | \"jti\">,\n  expiresIn?: number\n): Promise<string> {\n  const secretKey = getSecretKey()\n  const now = Date.now()\n  const expiry = payload.type === \"refresh\" ? REFRESH_TOKEN_EXPIRY : TOKEN_EXPIRY\n  \n  const fullPayload: JWTPayload = {\n    ...payload,\n    iat: now,\n    exp: now + (expiresIn || expiry),\n    jti: generateUUID(),\n  }\n  \n  const header = { alg: JWT_ALGORITHM, typ: \"JWT\" }\n  const encodedHeader = base64UrlEncode(JSON.stringify(header))\n  const encodedPayload = base64UrlEncode(JSON.stringify(fullPayload))\n  \n  const signature = await hmacSign(`${encodedHeader}.${encodedPayload}`, secretKey)\n  \n  return `${encodedHeader}.${encodedPayload}.${signature}`\n}\n\n// Verify and decode JWT Token\nexport async function verifyJWT(token: string): Promise<JWTPayload | null> {\n  try {\n    const parts = token.split(\".\")\n    if (parts.length !== 3) return null\n    \n    const [encodedHeader, encodedPayload, signature] = parts\n    const secretKey = getSecretKey()\n    \n    // Verify signature\n    const isValid = await hmacVerify(`${encodedHeader}.${encodedPayload}`, signature, secretKey)\n    if (!isValid) return null\n    \n    // Decode payload\n    const payload: JWTPayload = JSON.parse(base64UrlDecode(encodedPayload))\n    \n    // Check expiration\n    if (payload.exp < Date.now()) return null\n    \n    return payload\n  } catch {\n    return null\n  }\n}\n\n// Hash PIN using PBKDF2 (Web Crypto compatible)\nexport async function hashPIN(pin: string, salt?: string): Promise<{ hash: string; salt: string }> {\n  const pinSalt = salt || generateSecureRandom(32)\n  \n  const keyMaterial = await crypto.subtle.importKey(\n    \"raw\",\n    new TextEncoder().encode(pin),\n    \"PBKDF2\",\n    false,\n    [\"deriveBits\"]\n  )\n  \n  const derivedBits = await crypto.subtle.deriveBits(\n    {\n      name: \"PBKDF2\",\n      salt: new TextEncoder().encode(pinSalt),\n      iterations: 100000,\n      hash: \"SHA-256\",\n    },\n    keyMaterial,\n    256\n  )\n  \n  const hash = Array.from(new Uint8Array(derivedBits), (byte) =>\n    byte.toString(16).padStart(2, \"0\")\n  ).join(\"\")\n  \n  return { hash, salt: pinSalt }\n}\n\n// Verify PIN\nexport async function verifyPIN(pin: string, storedHash: string, salt: string): Promise<boolean> {\n  const { hash } = await hashPIN(pin, salt)\n  \n  // Timing-safe comparison\n  if (hash.length !== storedHash.length) return false\n  \n  let result = 0\n  for (let i = 0; i < hash.length; i++) {\n    result |= hash.charCodeAt(i) ^ storedHash.charCodeAt(i)\n  }\n  \n  return result === 0\n}\n\n// Generate TOTP Secret (for 2FA)\nexport function generateTOTPSecret(): string {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n  let secret = \"\"\n  const array = new Uint8Array(32)\n  crypto.getRandomValues(array)\n  \n  for (let i = 0; i < 32; i++) {\n    secret += chars[array[i] % chars.length]\n  }\n  \n  return secret\n}\n\n// Verify TOTP Code\nexport async function verifyTOTP(secret: string, code: string, window: number = 1): Promise<boolean> {\n  if (!code || code.length !== 6 || !/^\\d{6}$/.test(code)) return false\n  \n  const time = Math.floor(Date.now() / 30000)\n  \n  for (let i = -window; i <= window; i++) {\n    const expectedCode = await generateTOTPCode(secret, time + i)\n    \n    // Timing-safe comparison\n    if (expectedCode.length === code.length) {\n      let result = 0\n      for (let j = 0; j < code.length; j++) {\n        result |= code.charCodeAt(j) ^ expectedCode.charCodeAt(j)\n      }\n      if (result === 0) return true\n    }\n  }\n  \n  return false\n}\n\n// Generate TOTP Code\nasync function generateTOTPCode(secret: string, counter: number): Promise<string> {\n  // Decode base32 secret\n  const base32Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n  let bits = \"\"\n  for (const char of secret.toUpperCase()) {\n    const val = base32Chars.indexOf(char)\n    if (val === -1) continue\n    bits += val.toString(2).padStart(5, \"0\")\n  }\n  \n  const secretBytes = new Uint8Array(Math.floor(bits.length / 8))\n  for (let i = 0; i < secretBytes.length; i++) {\n    secretBytes[i] = parseInt(bits.substr(i * 8, 8), 2)\n  }\n  \n  // Create counter buffer (8 bytes, big-endian)\n  const counterBuffer = new ArrayBuffer(8)\n  const counterView = new DataView(counterBuffer)\n  counterView.setUint32(4, counter, false)\n  \n  // HMAC-SHA1\n  const key = await crypto.subtle.importKey(\n    \"raw\",\n    secretBytes,\n    { name: \"HMAC\", hash: \"SHA-1\" },\n    false,\n    [\"sign\"]\n  )\n  \n  const signature = await crypto.subtle.sign(\"HMAC\", key, counterBuffer)\n  const hmacResult = new Uint8Array(signature)\n  \n  // Dynamic truncation\n  const offset = hmacResult[hmacResult.length - 1] & 0xf\n  const binary =\n    ((hmacResult[offset] & 0x7f) << 24) |\n    ((hmacResult[offset + 1] & 0xff) << 16) |\n    ((hmacResult[offset + 2] & 0xff) << 8) |\n    (hmacResult[offset + 3] & 0xff)\n  \n  const otp = binary % 1000000\n  return otp.toString().padStart(6, \"0\")\n}\n\n// Generate secure API key\nexport function generateAPIKey(): string {\n  const prefix = \"pf_live_\"\n  const key = generateSecureRandom(32)\n  return `${prefix}${key}`\n}\n\n// Hash API key for storage\nexport async function hashAPIKey(apiKey: string): Promise<string> {\n  const encoder = new TextEncoder()\n  const data = encoder.encode(apiKey)\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data)\n  const hashArray = new Uint8Array(hashBuffer)\n  return Array.from(hashArray, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\")\n}\n\n// Encrypt sensitive data (AES-GCM)\nexport async function encryptData(data: string, key?: string): Promise<{ encrypted: string; iv: string }> {\n  const secretKey = key || process.env.ENCRYPTION_KEY || process.env.JWT_SECRET\n  if (!secretKey) throw new Error(\"Encryption key not configured\")\n  \n  const encoder = new TextEncoder()\n  const iv = crypto.getRandomValues(new Uint8Array(12))\n  \n  const keyMaterial = await crypto.subtle.importKey(\n    \"raw\",\n    encoder.encode(secretKey.slice(0, 32).padEnd(32, \"0\")),\n    \"AES-GCM\",\n    false,\n    [\"encrypt\"]\n  )\n  \n  const encrypted = await crypto.subtle.encrypt(\n    { name: \"AES-GCM\", iv },\n    keyMaterial,\n    encoder.encode(data)\n  )\n  \n  return {\n    encrypted: btoa(String.fromCharCode(...new Uint8Array(encrypted))),\n    iv: btoa(String.fromCharCode(...iv)),\n  }\n}\n\n// Decrypt sensitive data (AES-GCM)\nexport async function decryptData(encrypted: string, iv: string, key?: string): Promise<string> {\n  const secretKey = key || process.env.ENCRYPTION_KEY || process.env.JWT_SECRET\n  if (!secretKey) throw new Error(\"Encryption key not configured\")\n  \n  const decoder = new TextDecoder()\n  const ivArray = new Uint8Array(atob(iv).split(\"\").map((c) => c.charCodeAt(0)))\n  const encryptedArray = new Uint8Array(atob(encrypted).split(\"\").map((c) => c.charCodeAt(0)))\n  \n  const keyMaterial = await crypto.subtle.importKey(\n    \"raw\",\n    new TextEncoder().encode(secretKey.slice(0, 32).padEnd(32, \"0\")),\n    \"AES-GCM\",\n    false,\n    [\"decrypt\"]\n  )\n  \n  const decrypted = await crypto.subtle.decrypt(\n    { name: \"AES-GCM\", iv: ivArray },\n    keyMaterial,\n    encryptedArray\n  )\n  \n  return decoder.decode(decrypted)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/security/rate-limiter.ts"],"sourcesContent":["/**\n * Rate Limiter - Prevents brute force and DDoS attacks\n * Uses in-memory storage (use Redis in production)\n */\n\ninterface RateLimitEntry {\n  count: number\n  firstRequest: number\n  blockedUntil?: number\n}\n\ninterface RateLimitConfig {\n  maxRequests: number\n  windowMs: number\n  blockDurationMs: number\n}\n\n// Different rate limit configs for different endpoints\nexport const RATE_LIMITS: Record<string, RateLimitConfig> = {\n  // Auth endpoints - very strict\n  \"auth/login\": { maxRequests: 5, windowMs: 60000, blockDurationMs: 900000 }, // 5 req/min, block 15min\n  \"auth/register\": { maxRequests: 3, windowMs: 60000, blockDurationMs: 3600000 }, // 3 req/min, block 1hr\n  \"auth/2fa\": { maxRequests: 5, windowMs: 60000, blockDurationMs: 900000 }, // 5 req/min, block 15min\n  \n  // PIN validation - very strict\n  \"security/pin\": { maxRequests: 5, windowMs: 300000, blockDurationMs: 900000 }, // 5 req/5min, block 15min\n  \n  // Transactions - moderate\n  \"transfers\": { maxRequests: 10, windowMs: 60000, blockDurationMs: 300000 }, // 10 req/min, block 5min\n  \"deposits\": { maxRequests: 10, windowMs: 60000, blockDurationMs: 300000 }, // 10 req/min, block 5min\n  \n  // Webhooks - moderate\n  \"webhooks\": { maxRequests: 30, windowMs: 60000, blockDurationMs: 60000 }, // 30 req/min, block 1min\n  \n  // Default\n  default: { maxRequests: 100, windowMs: 60000, blockDurationMs: 60000 }, // 100 req/min, block 1min\n}\n\n// In-memory storage (replace with Redis in production)\nconst rateLimitStore = new Map<string, RateLimitEntry>()\n\n// Clean up old entries periodically\nsetInterval(() => {\n  const now = Date.now()\n  for (const [key, entry] of rateLimitStore.entries()) {\n    const config = getConfigForKey(key)\n    if (now - entry.firstRequest > config.windowMs * 2) {\n      rateLimitStore.delete(key)\n    }\n  }\n}, 60000)\n\nfunction getConfigForKey(key: string): RateLimitConfig {\n  // Extract endpoint type from key\n  for (const [endpoint, config] of Object.entries(RATE_LIMITS)) {\n    if (key.includes(endpoint)) {\n      return config\n    }\n  }\n  return RATE_LIMITS.default\n}\n\nexport interface RateLimitResult {\n  allowed: boolean\n  remaining: number\n  resetAt: number\n  blockedUntil?: number\n  retryAfter?: number\n}\n\nexport function checkRateLimit(\n  identifier: string, // IP or user ID\n  endpoint: string\n): RateLimitResult {\n  const key = `${endpoint}:${identifier}`\n  const config = RATE_LIMITS[endpoint] || RATE_LIMITS.default\n  const now = Date.now()\n  \n  let entry = rateLimitStore.get(key)\n  \n  // Check if blocked\n  if (entry?.blockedUntil && now < entry.blockedUntil) {\n    return {\n      allowed: false,\n      remaining: 0,\n      resetAt: entry.blockedUntil,\n      blockedUntil: entry.blockedUntil,\n      retryAfter: Math.ceil((entry.blockedUntil - now) / 1000),\n    }\n  }\n  \n  // Reset if window expired\n  if (!entry || now - entry.firstRequest > config.windowMs) {\n    entry = { count: 0, firstRequest: now }\n  }\n  \n  entry.count++\n  \n  // Check if limit exceeded\n  if (entry.count > config.maxRequests) {\n    entry.blockedUntil = now + config.blockDurationMs\n    rateLimitStore.set(key, entry)\n    \n    return {\n      allowed: false,\n      remaining: 0,\n      resetAt: entry.blockedUntil,\n      blockedUntil: entry.blockedUntil,\n      retryAfter: Math.ceil(config.blockDurationMs / 1000),\n    }\n  }\n  \n  rateLimitStore.set(key, entry)\n  \n  return {\n    allowed: true,\n    remaining: config.maxRequests - entry.count,\n    resetAt: entry.firstRequest + config.windowMs,\n  }\n}\n\n// Track failed attempts (for PIN, login, etc.)\nconst failedAttemptsStore = new Map<string, { count: number; lastAttempt: number }>()\n\nexport function trackFailedAttempt(\n  identifier: string,\n  maxAttempts: number = 5,\n  windowMs: number = 900000 // 15 minutes\n): { blocked: boolean; attemptsRemaining: number; resetAt?: number } {\n  const now = Date.now()\n  let entry = failedAttemptsStore.get(identifier)\n  \n  // Reset if window expired\n  if (!entry || now - entry.lastAttempt > windowMs) {\n    entry = { count: 0, lastAttempt: now }\n  }\n  \n  entry.count++\n  entry.lastAttempt = now\n  failedAttemptsStore.set(identifier, entry)\n  \n  if (entry.count >= maxAttempts) {\n    return {\n      blocked: true,\n      attemptsRemaining: 0,\n      resetAt: entry.lastAttempt + windowMs,\n    }\n  }\n  \n  return {\n    blocked: false,\n    attemptsRemaining: maxAttempts - entry.count,\n  }\n}\n\nexport function resetFailedAttempts(identifier: string): void {\n  failedAttemptsStore.delete(identifier)\n}\n\n// IP extraction utility\nexport function getClientIP(request: Request): string {\n  const forwarded = request.headers.get(\"x-forwarded-for\")\n  if (forwarded) {\n    return forwarded.split(\",\")[0].trim()\n  }\n  \n  const realIP = request.headers.get(\"x-real-ip\")\n  if (realIP) {\n    return realIP\n  }\n  \n  return \"unknown\"\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 471, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/security/auth-middleware.ts"],"sourcesContent":["/**\n * Authentication Middleware\n * Handles JWT verification, API key validation, and request authentication\n */\n\nimport { NextRequest, NextResponse } from \"next/server\"\nimport { verifyJWT, type JWTPayload, hashAPIKey } from \"./crypto\"\nimport { checkRateLimit, getClientIP } from \"./rate-limiter\"\n\n// Security headers to add to all responses\nexport const SECURITY_HEADERS = {\n  \"X-Content-Type-Options\": \"nosniff\",\n  \"X-Frame-Options\": \"DENY\",\n  \"X-XSS-Protection\": \"1; mode=block\",\n  \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n  \"Permissions-Policy\": \"camera=(), microphone=(), geolocation=()\",\n  \"Content-Security-Policy\": \"default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://accounts.google.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https:; frame-src 'self' https://accounts.google.com;\",\n}\n\nexport interface AuthResult {\n  authenticated: boolean\n  user?: JWTPayload\n  error?: string\n  statusCode?: number\n}\n\nexport interface APIKeyResult {\n  valid: boolean\n  userId?: string\n  permissions?: string[]\n  error?: string\n}\n\n// Verify JWT from Authorization header\nexport async function verifyAuth(request: NextRequest): Promise<AuthResult> {\n  try {\n    const authHeader = request.headers.get(\"authorization\")\n    \n    if (!authHeader) {\n      return { authenticated: false, error: \"No authorization header\", statusCode: 401 }\n    }\n    \n    // Check for Bearer token\n    if (!authHeader.startsWith(\"Bearer \")) {\n      return { authenticated: false, error: \"Invalid authorization format\", statusCode: 401 }\n    }\n    \n    const token = authHeader.slice(7)\n    \n    if (!token || token.length < 10) {\n      return { authenticated: false, error: \"Invalid token\", statusCode: 401 }\n    }\n    \n    // Verify JWT\n    const payload = await verifyJWT(token)\n    \n    if (!payload) {\n      return { authenticated: false, error: \"Invalid or expired token\", statusCode: 401 }\n    }\n    \n    // Check if access token (not refresh)\n    if (payload.type !== \"access\") {\n      return { authenticated: false, error: \"Invalid token type\", statusCode: 401 }\n    }\n    \n    return { authenticated: true, user: payload }\n  } catch (error) {\n    console.error(\"[Auth] Verification error:\", error)\n    return { authenticated: false, error: \"Authentication failed\", statusCode: 500 }\n  }\n}\n\n// Verify API Key from X-API-Key header\nexport async function verifyAPIKey(request: NextRequest): Promise<APIKeyResult> {\n  try {\n    const apiKey = request.headers.get(\"x-api-key\")\n    \n    if (!apiKey) {\n      return { valid: false, error: \"No API key provided\" }\n    }\n    \n    // Check API key format\n    if (!apiKey.startsWith(\"pf_live_\") && !apiKey.startsWith(\"pf_test_\")) {\n      return { valid: false, error: \"Invalid API key format\" }\n    }\n    \n    // Hash the API key for comparison\n    const hashedKey = await hashAPIKey(apiKey)\n    \n    // In production: Look up hashed key in database\n    // const apiKeyRecord = await db.apiKeys.findByHash(hashedKey)\n    \n    // For now, validate format only\n    return {\n      valid: true,\n      userId: \"api_user\", // Would come from database\n      permissions: [\"read\", \"write\"],\n    }\n  } catch (error) {\n    console.error(\"[APIKey] Verification error:\", error)\n    return { valid: false, error: \"API key verification failed\" }\n  }\n}\n\n// Combined auth middleware for route handlers\nexport async function withAuth(\n  request: NextRequest,\n  handler: (request: NextRequest, user: JWTPayload) => Promise<NextResponse>,\n  options: {\n    endpoint?: string\n    requireAuth?: boolean\n    allowAPIKey?: boolean\n  } = {}\n): Promise<NextResponse> {\n  const { endpoint = \"default\", requireAuth = true, allowAPIKey = false } = options\n  \n  // Rate limiting\n  const clientIP = getClientIP(request)\n  const rateLimit = checkRateLimit(clientIP, endpoint)\n  \n  if (!rateLimit.allowed) {\n    return NextResponse.json(\n      {\n        error: \"Rate limit exceeded\",\n        retryAfter: rateLimit.retryAfter,\n      },\n      {\n        status: 429,\n        headers: {\n          ...SECURITY_HEADERS,\n          \"Retry-After\": String(rateLimit.retryAfter || 60),\n          \"X-RateLimit-Remaining\": \"0\",\n          \"X-RateLimit-Reset\": String(rateLimit.resetAt),\n        },\n      }\n    )\n  }\n  \n  // Try API Key first if allowed\n  if (allowAPIKey) {\n    const apiKeyResult = await verifyAPIKey(request)\n    if (apiKeyResult.valid) {\n      const syntheticUser: JWTPayload = {\n        sub: apiKeyResult.userId || \"api_user\",\n        email: \"api@fluxpay.com\",\n        iat: Date.now(),\n        exp: Date.now() + 3600000,\n        jti: crypto.randomUUID(),\n        type: \"access\",\n      }\n      \n      const response = await handler(request, syntheticUser)\n      \n      // Add security headers and rate limit info\n      Object.entries(SECURITY_HEADERS).forEach(([key, value]) => {\n        response.headers.set(key, value)\n      })\n      response.headers.set(\"X-RateLimit-Remaining\", String(rateLimit.remaining))\n      response.headers.set(\"X-RateLimit-Reset\", String(rateLimit.resetAt))\n      \n      return response\n    }\n  }\n  \n  // Verify JWT\n  const authResult = await verifyAuth(request)\n  \n  if (requireAuth && !authResult.authenticated) {\n    return NextResponse.json(\n      { error: authResult.error || \"Unauthorized\" },\n      {\n        status: authResult.statusCode || 401,\n        headers: SECURITY_HEADERS,\n      }\n    )\n  }\n  \n  // Call handler with user\n  const response = await handler(request, authResult.user!)\n  \n  // Add security headers and rate limit info\n  Object.entries(SECURITY_HEADERS).forEach(([key, value]) => {\n    response.headers.set(key, value)\n  })\n  response.headers.set(\"X-RateLimit-Remaining\", String(rateLimit.remaining))\n  response.headers.set(\"X-RateLimit-Reset\", String(rateLimit.resetAt))\n  \n  return response\n}\n\n// Validate request body schema\nexport function validateRequestBody<T>(\n  body: unknown,\n  requiredFields: (keyof T)[],\n  validators?: Partial<Record<keyof T, (value: unknown) => boolean>>\n): { valid: boolean; error?: string; data?: T } {\n  if (!body || typeof body !== \"object\") {\n    return { valid: false, error: \"Invalid request body\" }\n  }\n  \n  const data = body as Record<string, unknown>\n  \n  // Check required fields\n  for (const field of requiredFields) {\n    if (!(field as string in data) || data[field as string] === undefined || data[field as string] === null) {\n      return { valid: false, error: `Missing required field: ${String(field)}` }\n    }\n  }\n  \n  // Run custom validators\n  if (validators) {\n    for (const [field, validator] of Object.entries(validators)) {\n      if (validator && !validator(data[field])) {\n        return { valid: false, error: `Invalid value for field: ${field}` }\n      }\n    }\n  }\n  \n  return { valid: true, data: data as T }\n}\n\n// Input sanitization\nexport function sanitizeInput(input: string): string {\n  return input\n    .trim()\n    .replace(/[<>]/g, \"\") // Remove HTML brackets\n    .replace(/javascript:/gi, \"\") // Remove javascript: URLs\n    .replace(/on\\w+=/gi, \"\") // Remove event handlers\n    .slice(0, 10000) // Limit length\n}\n\n// Validate email format\nexport function isValidEmail(email: string): boolean {\n  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n  return emailRegex.test(email) && email.length <= 254\n}\n\n// Validate CPF (Brazilian ID)\nexport function isValidCPF(cpf: string): boolean {\n  const cleanCPF = cpf.replace(/\\D/g, \"\")\n  \n  if (cleanCPF.length !== 11) return false\n  if (/^(\\d)\\1{10}$/.test(cleanCPF)) return false // All same digits\n  \n  // Validate check digits\n  let sum = 0\n  for (let i = 0; i < 9; i++) {\n    sum += parseInt(cleanCPF[i]) * (10 - i)\n  }\n  let remainder = (sum * 10) % 11\n  if (remainder === 10) remainder = 0\n  if (remainder !== parseInt(cleanCPF[9])) return false\n  \n  sum = 0\n  for (let i = 0; i < 10; i++) {\n    sum += parseInt(cleanCPF[i]) * (11 - i)\n  }\n  remainder = (sum * 10) % 11\n  if (remainder === 10) remainder = 0\n  if (remainder !== parseInt(cleanCPF[10])) return false\n  \n  return true\n}\n\n// Validate phone number (Brazilian format)\nexport function isValidPhone(phone: string): boolean {\n  const cleanPhone = phone.replace(/\\D/g, \"\")\n  return cleanPhone.length >= 10 && cleanPhone.length <= 11\n}\n\n// Validate PIN format\nexport function isValidPIN(pin: string): boolean {\n  return /^\\d{6}$/.test(pin)\n}\n\n// Log security event\nexport function logSecurityEvent(\n  event: string,\n  details: Record<string, unknown>,\n  severity: \"info\" | \"warning\" | \"critical\" = \"info\"\n): void {\n  const logEntry = {\n    timestamp: new Date().toISOString(),\n    event,\n    severity,\n    ...details,\n  }\n  \n  // In production: Send to security logging service (e.g., Datadog, Splunk)\n  console.log(`[Security:${severity.toUpperCase()}]`, JSON.stringify(logEntry))\n  \n  // For critical events, send Discord notification\n  if (severity === \"critical\" && process.env.DISCORD_ADMIN_WEBHOOK) {\n    fetch(process.env.DISCORD_ADMIN_WEBHOOK, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        username: \"fluxpay Security\",\n        embeds: [{\n          title: `Security Alert: ${event}`,\n          color: 0xff0000,\n          fields: Object.entries(details).map(([name, value]) => ({\n            name,\n            value: String(value),\n            inline: true,\n          })),\n          timestamp: new Date().toISOString(),\n        }],\n      }),\n    }).catch(() => {})\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 777, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/security/audit-log.ts"],"sourcesContent":["/**\n * Audit Logger - Records all security-relevant actions\n * Immutable audit trail for compliance and forensics\n */\n\nexport type AuditAction =\n  | \"user.created\"\n  | \"user.login\"\n  | \"user.login_failed\"\n  | \"user.logout\"\n  | \"user.2fa_enabled\"\n  | \"user.2fa_disabled\"\n  | \"user.pin_changed\"\n  | \"user.pin_failed\"\n  | \"transfer.initiated\"\n  | \"transfer.completed\"\n  | \"transfer.failed\"\n  | \"deposit.initiated\"\n  | \"deposit.completed\"\n  | \"deposit.failed\"\n  | \"api_key.created\"\n  | \"api_key.revoked\"\n  | \"webhook.configured\"\n  | \"webhook.triggered\"\n  | \"security.rate_limited\"\n  | \"security.suspicious_activity\"\n  | \"security.account_locked\"\n  | \"security.account_unlocked\"\n\nexport interface AuditEntry {\n  id: string\n  timestamp: string\n  action: AuditAction\n  userId?: string\n  userEmail?: string\n  ipAddress: string\n  userAgent?: string\n  resource?: string\n  resourceId?: string\n  details?: Record<string, unknown>\n  metadata?: {\n    requestId?: string\n    sessionId?: string\n    geoLocation?: {\n      country?: string\n      city?: string\n    }\n  }\n  hash?: string // Integrity hash of the entry\n}\n\n// In-memory store (use database in production)\nconst auditLog: AuditEntry[] = []\n\n// Generate integrity hash for audit entry\nasync function generateEntryHash(entry: Omit<AuditEntry, \"hash\">): Promise<string> {\n  const data = JSON.stringify(entry)\n  const encoder = new TextEncoder()\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", encoder.encode(data))\n  const hashArray = new Uint8Array(hashBuffer)\n  return Array.from(hashArray, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\")\n}\n\n// Create audit log entry\nexport async function createAuditEntry(\n  action: AuditAction,\n  params: {\n    userId?: string\n    userEmail?: string\n    ipAddress: string\n    userAgent?: string\n    resource?: string\n    resourceId?: string\n    details?: Record<string, unknown>\n    requestId?: string\n    sessionId?: string\n  }\n): Promise<AuditEntry> {\n  const entry: Omit<AuditEntry, \"hash\"> = {\n    id: crypto.randomUUID(),\n    timestamp: new Date().toISOString(),\n    action,\n    userId: params.userId,\n    userEmail: params.userEmail,\n    ipAddress: params.ipAddress,\n    userAgent: params.userAgent,\n    resource: params.resource,\n    resourceId: params.resourceId,\n    details: params.details,\n    metadata: {\n      requestId: params.requestId,\n      sessionId: params.sessionId,\n    },\n  }\n\n  // Generate integrity hash\n  const hash = await generateEntryHash(entry)\n  const completeEntry: AuditEntry = { ...entry, hash }\n\n  // Store entry\n  auditLog.push(completeEntry)\n\n  // Keep only last 10000 entries in memory (in production, use database)\n  if (auditLog.length > 10000) {\n    auditLog.shift()\n  }\n\n  // Log to console for development\n  console.log(`[Audit] ${action}`, {\n    userId: params.userId,\n    ip: params.ipAddress,\n    resource: params.resource,\n  })\n\n  // Send critical events to Discord\n  const criticalActions: AuditAction[] = [\n    \"security.suspicious_activity\",\n    \"security.account_locked\",\n    \"transfer.failed\",\n    \"user.login_failed\",\n  ]\n\n  if (criticalActions.includes(action) && process.env.DISCORD_ADMIN_WEBHOOK) {\n    sendDiscordAlert(completeEntry)\n  }\n\n  return completeEntry\n}\n\n// Send Discord alert for critical events\nasync function sendDiscordAlert(entry: AuditEntry): Promise<void> {\n  const webhookUrl = process.env.DISCORD_ADMIN_WEBHOOK\n  if (!webhookUrl) return\n\n  const colorMap: Record<string, number> = {\n    \"security.suspicious_activity\": 0xff0000,\n    \"security.account_locked\": 0xff6600,\n    \"security.rate_limited\": 0xffcc00,\n    \"transfer.failed\": 0xff9900,\n    \"user.login_failed\": 0xffcc00,\n  }\n\n  try {\n    await fetch(webhookUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        username: \"fluxpay Security\",\n        avatar_url: \"https://ui-avatars.com/api/?name=Security&background=ff0000&color=fff\",\n        embeds: [\n          {\n            title: `Audit Alert: ${entry.action}`,\n            color: colorMap[entry.action] || 0xff0000,\n            fields: [\n              { name: \"User ID\", value: entry.userId || \"N/A\", inline: true },\n              { name: \"IP Address\", value: entry.ipAddress, inline: true },\n              { name: \"Resource\", value: entry.resource || \"N/A\", inline: true },\n              {\n                name: \"Details\",\n                value: entry.details ? JSON.stringify(entry.details).slice(0, 500) : \"N/A\",\n                inline: false,\n              },\n            ],\n            footer: { text: `Entry ID: ${entry.id}` },\n            timestamp: entry.timestamp,\n          },\n        ],\n      }),\n    })\n  } catch (error) {\n    console.error(\"[Audit] Failed to send Discord alert:\", error)\n  }\n}\n\n// Query audit log\nexport function queryAuditLog(params: {\n  userId?: string\n  action?: AuditAction\n  startDate?: Date\n  endDate?: Date\n  limit?: number\n  offset?: number\n}): AuditEntry[] {\n  let results = [...auditLog]\n\n  if (params.userId) {\n    results = results.filter((e) => e.userId === params.userId)\n  }\n\n  if (params.action) {\n    results = results.filter((e) => e.action === params.action)\n  }\n\n  if (params.startDate) {\n    results = results.filter((e) => new Date(e.timestamp) >= params.startDate!)\n  }\n\n  if (params.endDate) {\n    results = results.filter((e) => new Date(e.timestamp) <= params.endDate!)\n  }\n\n  // Sort by timestamp descending\n  results.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\n\n  // Apply pagination\n  const offset = params.offset || 0\n  const limit = params.limit || 100\n\n  return results.slice(offset, offset + limit)\n}\n\n// Verify entry integrity\nexport async function verifyEntryIntegrity(entry: AuditEntry): Promise<boolean> {\n  const { hash, ...entryWithoutHash } = entry\n  const expectedHash = await generateEntryHash(entryWithoutHash)\n  return hash === expectedHash\n}\n\n// Export audit log (for compliance)\nexport function exportAuditLog(\n  format: \"json\" | \"csv\" = \"json\"\n): string {\n  if (format === \"csv\") {\n    const headers = [\"id\", \"timestamp\", \"action\", \"userId\", \"userEmail\", \"ipAddress\", \"resource\", \"resourceId\"]\n    const rows = auditLog.map((entry) =>\n      headers.map((h) => JSON.stringify(entry[h as keyof AuditEntry] || \"\")).join(\",\")\n    )\n    return [headers.join(\",\"), ...rows].join(\"\\n\")\n  }\n\n  return JSON.stringify(auditLog, null, 2)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/security/index.ts"],"sourcesContent":["/**\n * Security Module - Main Export\n * Centralized security utilities for fluxpay\n */\n\n// Cryptographic functions\nexport {\n  generateSecureRandom,\n  generateUUID,\n  createJWT,\n  verifyJWT,\n  hashPIN,\n  verifyPIN,\n  generateTOTPSecret,\n  verifyTOTP,\n  generateAPIKey,\n  hashAPIKey,\n  encryptData,\n  decryptData,\n  type JWTPayload,\n} from \"./crypto\"\n\n// Rate limiting\nexport {\n  checkRateLimit,\n  trackFailedAttempt,\n  resetFailedAttempts,\n  getClientIP,\n  RATE_LIMITS,\n  type RateLimitResult,\n} from \"./rate-limiter\"\n\n// Authentication middleware\nexport {\n  verifyAuth,\n  verifyAPIKey,\n  withAuth,\n  validateRequestBody,\n  sanitizeInput,\n  isValidEmail,\n  isValidCPF,\n  isValidPhone,\n  isValidPIN,\n  logSecurityEvent,\n  SECURITY_HEADERS,\n  type AuthResult,\n  type APIKeyResult,\n} from \"./auth-middleware\"\n\n// Audit logging\nexport {\n  createAuditEntry,\n  queryAuditLog,\n  verifyEntryIntegrity,\n  exportAuditLog,\n  type AuditAction,\n  type AuditEntry,\n} from \"./audit-log\"\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED,0BAA0B;;AAC1B;AAgBA,gBAAgB;AAChB;AASA,4BAA4B;AAC5B;AAgBA,gBAAgB;AAChB"}},
    {"offset": {"line": 977, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/app/api/auth/register/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport {\n  createJWT,\n  hashPIN,\n  generateUUID,\n  generateSecureRandom,\n  checkRateLimit,\n  getClientIP,\n  isValidEmail,\n  isValidCPF,\n  isValidPhone,\n  isValidPIN,\n  sanitizeInput,\n  createAuditEntry,\n  logSecurityEvent,\n  SECURITY_HEADERS,\n} from \"@/lib/security\"\n\n// Send notification to admin Discord webhook\nasync function notifyAdminNewAccount(user: {\n  id: string\n  email: string\n  nomeCompleto: string\n  cpf: string\n  telefone: string\n  dataNascimento: string\n  photoURL?: string\n  createdAt: string\n  ipAddress: string\n}) {\n  const webhookUrl = process.env.DISCORD_ADMIN_WEBHOOK\n  if (!webhookUrl) return\n\n  try {\n    const cpfMasked = user.cpf.replace(/(\\d{3})(\\d{3})(\\d{3})(\\d{2})/, \"$1.***.***-$4\")\n    const phoneMasked = user.telefone.replace(/(\\d{2})(\\d{5})(\\d{4})/, \"($1) *****-$3\")\n\n    await fetch(webhookUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        username: \"fluxpay Admin\",\n        avatar_url: \"https://ui-avatars.com/api/?name=PF&background=10b981&color=fff&bold=true\",\n        embeds: [{\n          title: \"Nova Conta Criada\",\n          color: 0x10b981,\n          thumbnail: {\n            url: user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.nomeCompleto)}&background=10b981&color=fff`\n          },\n          fields: [\n            { name: \"ID\", value: `\\`${user.id}\\``, inline: true },\n            { name: \"Nome\", value: user.nomeCompleto, inline: true },\n            { name: \"Email\", value: user.email, inline: false },\n            { name: \"CPF\", value: cpfMasked, inline: true },\n            { name: \"Telefone\", value: phoneMasked, inline: true },\n            { name: \"Data Nascimento\", value: user.dataNascimento, inline: true },\n            { name: \"IP\", value: user.ipAddress, inline: true },\n          ],\n          footer: { text: \"fluxpay Gateway - Sistema de Notificacoes\" },\n          timestamp: user.createdAt\n        }]\n      })\n    })\n  } catch (error) {\n    console.error(\"[Admin] Discord notification failed:\", error)\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  const clientIP = getClientIP(request)\n  const userAgent = request.headers.get(\"user-agent\") || \"unknown\"\n  const requestId = generateUUID()\n\n  try {\n    // Rate limiting\n    const rateLimit = checkRateLimit(clientIP, \"auth/register\")\n    if (!rateLimit.allowed) {\n      logSecurityEvent(\"registration_rate_limited\", { ip: clientIP }, \"warning\")\n      \n      await createAuditEntry(\"security.rate_limited\", {\n        ipAddress: clientIP,\n        userAgent,\n        resource: \"auth/register\",\n        requestId,\n      })\n\n      return NextResponse.json(\n        { error: \"Muitas tentativas. Tente novamente mais tarde.\", retryAfter: rateLimit.retryAfter },\n        { \n          status: 429, \n          headers: { \n            ...SECURITY_HEADERS,\n            \"Retry-After\": String(rateLimit.retryAfter || 60) \n          } \n        }\n      )\n    }\n\n    const body = await request.json()\n    const { googleId, email, nomeCompleto, cpf, dataNascimento, telefone, pin, photoURL } = body\n\n    // Validate required fields\n    if (!email || !nomeCompleto || !cpf || !dataNascimento || !telefone || !pin) {\n      return NextResponse.json(\n        { error: \"Campos obrigatorios ausentes\" },\n        { status: 400, headers: SECURITY_HEADERS }\n      )\n    }\n\n    // Sanitize inputs\n    const sanitizedEmail = sanitizeInput(email).toLowerCase()\n    const sanitizedName = sanitizeInput(nomeCompleto)\n    const sanitizedCPF = cpf.replace(/\\D/g, \"\")\n    const sanitizedPhone = telefone.replace(/\\D/g, \"\")\n\n    // Validate email\n    if (!isValidEmail(sanitizedEmail)) {\n      return NextResponse.json(\n        { error: \"Email invalido\" },\n        { status: 400, headers: SECURITY_HEADERS }\n      )\n    }\n\n    // Validate CPF\n    if (!isValidCPF(sanitizedCPF)) {\n      return NextResponse.json(\n        { error: \"CPF invalido\" },\n        { status: 400, headers: SECURITY_HEADERS }\n      )\n    }\n\n    // Validate phone\n    if (!isValidPhone(sanitizedPhone)) {\n      return NextResponse.json(\n        { error: \"Telefone invalido\" },\n        { status: 400, headers: SECURITY_HEADERS }\n      )\n    }\n\n    // Validate PIN\n    if (!isValidPIN(pin)) {\n      return NextResponse.json(\n        { error: \"PIN deve ter 6 digitos numericos\" },\n        { status: 400, headers: SECURITY_HEADERS }\n      )\n    }\n\n    // Validate date format\n    const dateRegex = /^\\d{2}\\/\\d{2}\\/\\d{4}$/\n    if (!dateRegex.test(dataNascimento)) {\n      return NextResponse.json(\n        { error: \"Data de nascimento invalida\" },\n        { status: 400, headers: SECURITY_HEADERS }\n      )\n    }\n\n    // IMPORTANT: Check if user already exists before creating\n    // In production: Check in real database\n    // For now using in-memory store, but this must check real API/database\n    // const existingUser = await db.users.findByEmail(sanitizedEmail) || await db.users.findByCPF(sanitizedCPF)\n    \n    // Simulated check - in production replace with real database check\n    const users: Record<string, any> = {} // This should be replaced with real database query\n    const existingUser = Object.values(users).find(\n      (u: any) => u.email === sanitizedEmail || u.cpf === sanitizedCPF || (googleId && u.googleId === googleId)\n    )\n\n    if (existingUser) {\n      // User already exists - do not create and do not send webhook\n      // Instead, return error that user exists\n      await createAuditEntry(\"security.suspicious_activity\", {\n        userEmail: sanitizedEmail,\n        ipAddress: clientIP,\n        userAgent,\n        resource: \"auth/register\",\n        details: {\n          reason: \"registration_attempt_existing_user\",\n          existingUserId: existingUser.id,\n        },\n        requestId,\n      })\n\n      return NextResponse.json(\n        { error: \"Usuario ja existe. Use o login.\" },\n        { status: 409, headers: SECURITY_HEADERS }\n      )\n    }\n\n    // Hash PIN securely\n    const { hash: pinHash, salt: pinSalt } = await hashPIN(pin)\n\n    // Generate user ID\n    const userId = `user_${generateSecureRandom(16)}`\n    const createdAt = new Date().toISOString()\n\n    const newUser = {\n      id: userId,\n      googleId: googleId || null,\n      email: sanitizedEmail,\n      nomeCompleto: sanitizedName,\n      cpf: sanitizedCPF,\n      dataNascimento,\n      telefone: sanitizedPhone,\n      photoURL: photoURL || null,\n      saldo: 0, // Saldo sempre zerado para novos usurios\n      createdAt,\n      twoFactorEnabled: false,\n      pinHash,\n      pinSalt,\n      apiKey: null,\n      lastLogin: null,\n      loginAttempts: 0,\n      lockedUntil: null,\n    }\n\n    // In production: Save to database\n    // await db.users.create(newUser)\n    // Store in memory (replace with real database)\n    users[userId] = newUser\n\n    // Create audit entry\n    await createAuditEntry(\"user.created\", {\n      userId: newUser.id,\n      userEmail: newUser.email,\n      ipAddress: clientIP,\n      userAgent,\n      resource: \"users\",\n      resourceId: newUser.id,\n      details: {\n        cpfLastDigits: sanitizedCPF.slice(-4),\n        hasGoogleId: !!googleId,\n      },\n      requestId,\n    })\n\n    // WEBHOOK: Only notify admin when user is actually created (not when already exists)\n    await notifyAdminNewAccount({\n      ...newUser,\n      ipAddress: clientIP,\n    })\n\n    // Generate JWT tokens\n    const accessToken = await createJWT({\n      sub: newUser.id,\n      email: newUser.email,\n      name: newUser.nomeCompleto,\n      type: \"access\",\n    })\n\n    const refreshToken = await createJWT({\n      sub: newUser.id,\n      email: newUser.email,\n      type: \"refresh\",\n    })\n\n    // Create response\n    const response = NextResponse.json({\n      success: true,\n      user: {\n        id: newUser.id,\n        email: newUser.email,\n        nomeCompleto: newUser.nomeCompleto,\n        photoURL: newUser.photoURL,\n        saldo: newUser.saldo,\n        twoFactorEnabled: newUser.twoFactorEnabled,\n      },\n      accessToken,\n      refreshToken,\n      expiresIn: 900, // 15 minutes\n    })\n\n    // Add security headers\n    Object.entries(SECURITY_HEADERS).forEach(([key, value]) => {\n      response.headers.set(key, value)\n    })\n\n    // Set refresh token as HTTP-only cookie\n    response.cookies.set(\"refresh_token\", refreshToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === \"production\",\n      sameSite: \"strict\",\n      maxAge: 7 * 24 * 60 * 60, // 7 days\n      path: \"/\",\n    })\n\n    return response\n  } catch (error) {\n    console.error(\"[Register] Error:\", error)\n    \n    logSecurityEvent(\"registration_error\", { \n      ip: clientIP, \n      error: error instanceof Error ? error.message : \"Unknown\" \n    }, \"warning\")\n\n    return NextResponse.json(\n      { error: \"Erro interno do servidor\" },\n      { status: 500, headers: SECURITY_HEADERS }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}