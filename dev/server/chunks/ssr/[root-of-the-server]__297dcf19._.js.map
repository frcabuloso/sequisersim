{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/auth-context.tsx"],"sourcesContent":["\"use client\"\n\nimport React, { createContext, useContext, useState, useEffect, useCallback } from \"react\"\nimport { useRouter, usePathname } from \"next/navigation\"\n\ninterface User {\n  id: string\n  email: string\n  name: string\n  picture: string\n  cpf: string\n  telefone: string\n  saldo: number\n  pin: string | null\n  twoFactorEnabled: boolean\n  createdAt: string\n}\n\ninterface AuthContextType {\n  user: User | null\n  isLoading: boolean\n  isAuthenticated: boolean\n  login: (userData: Partial<User>) => void\n  logout: () => void\n  updateUser: (data: Partial<User>) => void\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nconst PROTECTED_ROUTES = [\"/dashboard\"]\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const [user, setUser] = useState<User | null>(null)\n  const [isLoading, setIsLoading] = useState(true)\n  const router = useRouter()\n  const pathname = usePathname()\n\n  // Check if user is logged in on mount - verify token with API\n  useEffect(() => {\n    const checkAuth = async () => {\n      try {\n        const accessToken = localStorage.getItem(\"frcabuloso_access_token\")\n        const storedUser = localStorage.getItem(\"frcabuloso_user\")\n        \n        if (accessToken && storedUser) {\n          // Verify token is still valid\n          try {\n            const response = await fetch(\"/api/auth/verify\", {\n              method: \"GET\",\n              headers: {\n                \"Authorization\": `Bearer ${accessToken}`,\n              },\n            })\n            \n            if (response.ok) {\n              const data = await response.json()\n              setUser(data.user)\n            } else {\n              // Token invalid, try refresh\n              const refreshResponse = await fetch(\"/api/auth/login\", {\n                method: \"PUT\",\n                credentials: \"include\",\n              })\n              \n              if (refreshResponse.ok) {\n                const refreshData = await refreshResponse.json()\n                localStorage.setItem(\"frcabuloso_access_token\", refreshData.accessToken)\n                setUser(JSON.parse(storedUser))\n              } else {\n                // Refresh failed, clear auth\n                localStorage.removeItem(\"frcabuloso_user\")\n                localStorage.removeItem(\"frcabuloso_access_token\")\n                setUser(null)\n              }\n            }\n          } catch (error) {\n            // Network error or invalid token - clear auth\n            localStorage.removeItem(\"frcabuloso_user\")\n            localStorage.removeItem(\"frcabuloso_access_token\")\n            setUser(null)\n          }\n        } else {\n          setUser(null)\n        }\n      } catch (error) {\n        console.error(\"Error checking auth:\", error)\n        setUser(null)\n      } finally {\n        setIsLoading(false)\n      }\n    }\n    checkAuth()\n  }, [])\n\n  // Protect routes\n  useEffect(() => {\n    if (!isLoading) {\n      const isProtectedRoute = PROTECTED_ROUTES.some(route => pathname?.startsWith(route))\n      \n      if (isProtectedRoute && !user) {\n        router.push(\"/login\")\n      }\n    }\n  }, [isLoading, user, pathname, router])\n\n  const login = useCallback((userData: Partial<User>, accessToken?: string, refreshToken?: string) => {\n    const newUser: User = {\n      id: userData.id || \"\",\n      email: userData.email || \"\",\n      name: userData.name || \"\",\n      picture: userData.picture || \"\",\n      cpf: userData.cpf || \"\",\n      telefone: userData.telefone || \"\",\n      saldo: userData.saldo ?? 0, // Saldo inicial sempre zerado\n      pin: null, // Never store PIN in client\n      twoFactorEnabled: userData.twoFactorEnabled || false,\n      createdAt: userData.createdAt || new Date().toISOString(),\n    }\n    \n    setUser(newUser)\n    localStorage.setItem(\"frcabuloso_user\", JSON.stringify(newUser))\n    \n    // Store tokens\n    if (accessToken) {\n      localStorage.setItem(\"frcabuloso_access_token\", accessToken)\n    }\n    // Refresh token is stored in httpOnly cookie by server\n  }, [])\n\n  const logout = useCallback(async () => {\n    try {\n      const accessToken = localStorage.getItem(\"frcabuloso_access_token\")\n      \n      // Call logout API\n      if (accessToken) {\n        await fetch(\"/api/auth/login\", {\n          method: \"DELETE\",\n          headers: {\n            \"Authorization\": `Bearer ${accessToken}`,\n          },\n          credentials: \"include\",\n        }).catch(() => {\n          // Ignore errors on logout\n        })\n      }\n    } catch (error) {\n      // Ignore errors\n    } finally {\n      setUser(null)\n      localStorage.removeItem(\"frcabuloso_user\")\n      localStorage.removeItem(\"frcabuloso_access_token\")\n      router.push(\"/\")\n    }\n  }, [router])\n\n  const updateUser = useCallback((data: Partial<User>) => {\n    setUser(prev => {\n      if (!prev) return null\n      const updated = { ...prev, ...data }\n      localStorage.setItem(\"frcabuloso_user\", JSON.stringify(updated))\n      return updated\n    })\n  }, [])\n\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        isLoading,\n        isAuthenticated: !!user,\n        login,\n        logout,\n        updateUser,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error(\"useAuth must be used within an AuthProvider\")\n  }\n  return context\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/pwa-context.tsx"],"sourcesContent":["\"use client\"\n\nimport { createContext, useContext, useEffect, useState, type ReactNode } from \"react\"\n\ninterface PWAContextType {\n  isInstallable: boolean\n  isInstalled: boolean\n  isOnline: boolean\n  notificationsEnabled: boolean\n  installApp: () => Promise<void>\n  enableNotifications: () => Promise<boolean>\n  disableNotifications: () => void\n}\n\nconst PWAContext = createContext<PWAContextType | undefined>(undefined)\n\nexport function PWAProvider({ children }: { children: ReactNode }) {\n  const [isInstallable, setIsInstallable] = useState(false)\n  const [isInstalled, setIsInstalled] = useState(false)\n  const [isOnline, setIsOnline] = useState(true)\n  const [notificationsEnabled, setNotificationsEnabled] = useState(false)\n  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null)\n\n  useEffect(() => {\n    // Check if already installed\n    if (window.matchMedia('(display-mode: standalone)').matches) {\n      setIsInstalled(true)\n    }\n\n    // Check online status\n    setIsOnline(navigator.onLine)\n\n    const handleOnline = () => setIsOnline(true)\n    const handleOffline = () => setIsOnline(false)\n\n    window.addEventListener('online', handleOnline)\n    window.addEventListener('offline', handleOffline)\n\n    // Listen for install prompt\n    const handleBeforeInstallPrompt = (e: Event) => {\n      e.preventDefault()\n      setDeferredPrompt(e as BeforeInstallPromptEvent)\n      setIsInstallable(true)\n    }\n\n    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt)\n\n    // Listen for app installed\n    const handleAppInstalled = () => {\n      setIsInstalled(true)\n      setIsInstallable(false)\n      setDeferredPrompt(null)\n    }\n\n    window.addEventListener('appinstalled', handleAppInstalled)\n\n    // Check notifications permission\n    if ('Notification' in window) {\n      setNotificationsEnabled(Notification.permission === 'granted')\n    }\n\n    // Register service worker only in production\n    if ('serviceWorker' in navigator && process.env.NODE_ENV === 'production') {\n      navigator.serviceWorker.register('/sw.js')\n        .then((registration) => {\n          // Check for updates\n          registration.addEventListener('updatefound', () => {\n            const newWorker = registration.installing\n            if (newWorker) {\n              newWorker.addEventListener('statechange', () => {\n                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n                  // New version available\n                  if (confirm('Nova versao disponivel. Atualizar agora?')) {\n                    window.location.reload()\n                  }\n                }\n              })\n            }\n          })\n        })\n        .catch((error) => {\n          // Silently fail in development/preview environments\n          console.log('[PWA] Service worker registration skipped:', error.message)\n        })\n    }\n\n    return () => {\n      window.removeEventListener('online', handleOnline)\n      window.removeEventListener('offline', handleOffline)\n      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt)\n      window.removeEventListener('appinstalled', handleAppInstalled)\n    }\n  }, [])\n\n  const installApp = async () => {\n    if (!deferredPrompt) return\n\n    deferredPrompt.prompt()\n    const { outcome } = await deferredPrompt.userChoice\n\n    if (outcome === 'accepted') {\n      setIsInstalled(true)\n    }\n\n    setDeferredPrompt(null)\n    setIsInstallable(false)\n  }\n\n  const enableNotifications = async (): Promise<boolean> => {\n    if (!('Notification' in window)) return false\n\n    const permission = await Notification.requestPermission()\n    const enabled = permission === 'granted'\n    setNotificationsEnabled(enabled)\n\n    if (enabled && 'serviceWorker' in navigator) {\n      try {\n        const registration = await navigator.serviceWorker.ready\n        // Subscribe to push notifications only if VAPID key is configured\n        const vapidKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY\n        if (vapidKey) {\n          await registration.pushManager.subscribe({\n            userVisibleOnly: true,\n            applicationServerKey: vapidKey,\n          })\n        }\n      } catch (error) {\n        console.error('Failed to subscribe to push notifications:', error)\n      }\n    }\n\n    return enabled\n  }\n\n  const disableNotifications = () => {\n    setNotificationsEnabled(false)\n    // Note: Cannot programmatically revoke notification permission\n  }\n\n  return (\n    <PWAContext.Provider\n      value={{\n        isInstallable,\n        isInstalled,\n        isOnline,\n        notificationsEnabled,\n        installApp,\n        enableNotifications,\n        disableNotifications,\n      }}\n    >\n      {children}\n    </PWAContext.Provider>\n  )\n}\n\nexport function usePWA() {\n  const context = useContext(PWAContext)\n  if (context === undefined) {\n    throw new Error('usePWA must be used within a PWAProvider')\n  }\n  return context\n}\n\n// Type for beforeinstallprompt event\ninterface BeforeInstallPromptEvent extends Event {\n  prompt: () => Promise<void>\n  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AAFA;;;AAcA,MAAM,2BAAa,IAAA,sNAAa,EAA6B;AAEtD,SAAS,YAAY,EAAE,QAAQ,EAA2B;IAC/D,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,iNAAQ,EAAC;IACnD,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,iNAAQ,EAAC;IAC/C,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC;IACzC,MAAM,CAAC,sBAAsB,wBAAwB,GAAG,IAAA,iNAAQ,EAAC;IACjE,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,iNAAQ,EAAkC;IAEtF,IAAA,kNAAS,EAAC;QACR,6BAA6B;QAC7B,IAAI,OAAO,UAAU,CAAC,8BAA8B,OAAO,EAAE;YAC3D,eAAe;QACjB;QAEA,sBAAsB;QACtB,YAAY,UAAU,MAAM;QAE5B,MAAM,eAAe,IAAM,YAAY;QACvC,MAAM,gBAAgB,IAAM,YAAY;QAExC,OAAO,gBAAgB,CAAC,UAAU;QAClC,OAAO,gBAAgB,CAAC,WAAW;QAEnC,4BAA4B;QAC5B,MAAM,4BAA4B,CAAC;YACjC,EAAE,cAAc;YAChB,kBAAkB;YAClB,iBAAiB;QACnB;QAEA,OAAO,gBAAgB,CAAC,uBAAuB;QAE/C,2BAA2B;QAC3B,MAAM,qBAAqB;YACzB,eAAe;YACf,iBAAiB;YACjB,kBAAkB;QACpB;QAEA,OAAO,gBAAgB,CAAC,gBAAgB;QAExC,iCAAiC;QACjC,IAAI,kBAAkB,QAAQ;YAC5B,wBAAwB,aAAa,UAAU,KAAK;QACtD;QAEA,6CAA6C;QAC7C,IAAI,mBAAmB,aAAa,oDAAyB;;QAwB7D,OAAO;YACL,OAAO,mBAAmB,CAAC,UAAU;YACrC,OAAO,mBAAmB,CAAC,WAAW;YACtC,OAAO,mBAAmB,CAAC,uBAAuB;YAClD,OAAO,mBAAmB,CAAC,gBAAgB;QAC7C;IACF,GAAG,EAAE;IAEL,MAAM,aAAa;QACjB,IAAI,CAAC,gBAAgB;QAErB,eAAe,MAAM;QACrB,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,eAAe,UAAU;QAEnD,IAAI,YAAY,YAAY;YAC1B,eAAe;QACjB;QAEA,kBAAkB;QAClB,iBAAiB;IACnB;IAEA,MAAM,sBAAsB;QAC1B,IAAI,CAAC,CAAC,kBAAkB,MAAM,GAAG,OAAO;QAExC,MAAM,aAAa,MAAM,aAAa,iBAAiB;QACvD,MAAM,UAAU,eAAe;QAC/B,wBAAwB;QAExB,IAAI,WAAW,mBAAmB,WAAW;YAC3C,IAAI;gBACF,MAAM,eAAe,MAAM,UAAU,aAAa,CAAC,KAAK;gBACxD,kEAAkE;gBAClE,MAAM;gBACN,wCAAc;oBACZ,MAAM,aAAa,WAAW,CAAC,SAAS,CAAC;wBACvC,iBAAiB;wBACjB,sBAAsB;oBACxB;gBACF;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,8CAA8C;YAC9D;QACF;QAEA,OAAO;IACT;IAEA,MAAM,uBAAuB;QAC3B,wBAAwB;IACxB,+DAA+D;IACjE;IAEA,qBACE,8OAAC,WAAW,QAAQ;QAClB,OAAO;YACL;YACA;YACA;YACA;YACA;YACA;YACA;QACF;kBAEC;;;;;;AAGP;AAEO,SAAS;IACd,MAAM,UAAU,IAAA,mNAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT"}}]
}