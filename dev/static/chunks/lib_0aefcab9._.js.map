{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/auth-context.tsx"],"sourcesContent":["\"use client\"\n\nimport React, { createContext, useContext, useState, useEffect, useCallback } from \"react\"\nimport { useRouter, usePathname } from \"next/navigation\"\n\ninterface User {\n  id: string\n  email: string\n  name: string\n  picture: string\n  cpf: string\n  telefone: string\n  saldo: number\n  pin: string | null\n  twoFactorEnabled: boolean\n  createdAt: string\n}\n\ninterface AuthContextType {\n  user: User | null\n  isLoading: boolean\n  isAuthenticated: boolean\n  login: (userData: Partial<User>) => void\n  logout: () => void\n  updateUser: (data: Partial<User>) => void\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nconst PROTECTED_ROUTES = [\"/dashboard\"]\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const [user, setUser] = useState<User | null>(null)\n  const [isLoading, setIsLoading] = useState(true)\n  const router = useRouter()\n  const pathname = usePathname()\n\n  // Check if user is logged in on mount - verify token with API\n  useEffect(() => {\n    const checkAuth = async () => {\n      try {\n        const accessToken = localStorage.getItem(\"frcabuloso_access_token\")\n        const storedUser = localStorage.getItem(\"frcabuloso_user\")\n        \n        if (accessToken && storedUser) {\n          // Verify token is still valid\n          try {\n            const response = await fetch(\"/api/auth/verify\", {\n              method: \"GET\",\n              headers: {\n                \"Authorization\": `Bearer ${accessToken}`,\n              },\n            })\n            \n            if (response.ok) {\n              const data = await response.json()\n              setUser(data.user)\n            } else {\n              // Token invalid, try refresh\n              const refreshResponse = await fetch(\"/api/auth/login\", {\n                method: \"PUT\",\n                credentials: \"include\",\n              })\n              \n              if (refreshResponse.ok) {\n                const refreshData = await refreshResponse.json()\n                localStorage.setItem(\"frcabuloso_access_token\", refreshData.accessToken)\n                setUser(JSON.parse(storedUser))\n              } else {\n                // Refresh failed, clear auth\n                localStorage.removeItem(\"frcabuloso_user\")\n                localStorage.removeItem(\"frcabuloso_access_token\")\n                setUser(null)\n              }\n            }\n          } catch (error) {\n            // Network error or invalid token - clear auth\n            localStorage.removeItem(\"frcabuloso_user\")\n            localStorage.removeItem(\"frcabuloso_access_token\")\n            setUser(null)\n          }\n        } else {\n          setUser(null)\n        }\n      } catch (error) {\n        console.error(\"Error checking auth:\", error)\n        setUser(null)\n      } finally {\n        setIsLoading(false)\n      }\n    }\n    checkAuth()\n  }, [])\n\n  // Protect routes\n  useEffect(() => {\n    if (!isLoading) {\n      const isProtectedRoute = PROTECTED_ROUTES.some(route => pathname?.startsWith(route))\n      \n      if (isProtectedRoute && !user) {\n        router.push(\"/login\")\n      }\n    }\n  }, [isLoading, user, pathname, router])\n\n  const login = useCallback((userData: Partial<User>, accessToken?: string, refreshToken?: string) => {\n    const newUser: User = {\n      id: userData.id || \"\",\n      email: userData.email || \"\",\n      name: userData.name || \"\",\n      picture: userData.picture || \"\",\n      cpf: userData.cpf || \"\",\n      telefone: userData.telefone || \"\",\n      saldo: userData.saldo ?? 0, // Saldo inicial sempre zerado\n      pin: null, // Never store PIN in client\n      twoFactorEnabled: userData.twoFactorEnabled || false,\n      createdAt: userData.createdAt || new Date().toISOString(),\n    }\n    \n    setUser(newUser)\n    localStorage.setItem(\"frcabuloso_user\", JSON.stringify(newUser))\n    \n    // Store tokens\n    if (accessToken) {\n      localStorage.setItem(\"frcabuloso_access_token\", accessToken)\n    }\n    // Refresh token is stored in httpOnly cookie by server\n  }, [])\n\n  const logout = useCallback(async () => {\n    try {\n      const accessToken = localStorage.getItem(\"frcabuloso_access_token\")\n      \n      // Call logout API\n      if (accessToken) {\n        await fetch(\"/api/auth/login\", {\n          method: \"DELETE\",\n          headers: {\n            \"Authorization\": `Bearer ${accessToken}`,\n          },\n          credentials: \"include\",\n        }).catch(() => {\n          // Ignore errors on logout\n        })\n      }\n    } catch (error) {\n      // Ignore errors\n    } finally {\n      setUser(null)\n      localStorage.removeItem(\"frcabuloso_user\")\n      localStorage.removeItem(\"frcabuloso_access_token\")\n      router.push(\"/\")\n    }\n  }, [router])\n\n  const updateUser = useCallback((data: Partial<User>) => {\n    setUser(prev => {\n      if (!prev) return null\n      const updated = { ...prev, ...data }\n      localStorage.setItem(\"frcabuloso_user\", JSON.stringify(updated))\n      return updated\n    })\n  }, [])\n\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        isLoading,\n        isAuthenticated: !!user,\n        login,\n        logout,\n        updateUser,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error(\"useAuth must be used within an AuthProvider\")\n  }\n  return context\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/try/Downloads/BackupGeral/fr/web/carteiradigital/lib/pwa-context.tsx"],"sourcesContent":["\"use client\"\n\nimport { createContext, useContext, useEffect, useState, type ReactNode } from \"react\"\n\ninterface PWAContextType {\n  isInstallable: boolean\n  isInstalled: boolean\n  isOnline: boolean\n  notificationsEnabled: boolean\n  installApp: () => Promise<void>\n  enableNotifications: () => Promise<boolean>\n  disableNotifications: () => void\n}\n\nconst PWAContext = createContext<PWAContextType | undefined>(undefined)\n\nexport function PWAProvider({ children }: { children: ReactNode }) {\n  const [isInstallable, setIsInstallable] = useState(false)\n  const [isInstalled, setIsInstalled] = useState(false)\n  const [isOnline, setIsOnline] = useState(true)\n  const [notificationsEnabled, setNotificationsEnabled] = useState(false)\n  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null)\n\n  useEffect(() => {\n    // Check if already installed\n    if (window.matchMedia('(display-mode: standalone)').matches) {\n      setIsInstalled(true)\n    }\n\n    // Check online status\n    setIsOnline(navigator.onLine)\n\n    const handleOnline = () => setIsOnline(true)\n    const handleOffline = () => setIsOnline(false)\n\n    window.addEventListener('online', handleOnline)\n    window.addEventListener('offline', handleOffline)\n\n    // Listen for install prompt\n    const handleBeforeInstallPrompt = (e: Event) => {\n      e.preventDefault()\n      setDeferredPrompt(e as BeforeInstallPromptEvent)\n      setIsInstallable(true)\n    }\n\n    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt)\n\n    // Listen for app installed\n    const handleAppInstalled = () => {\n      setIsInstalled(true)\n      setIsInstallable(false)\n      setDeferredPrompt(null)\n    }\n\n    window.addEventListener('appinstalled', handleAppInstalled)\n\n    // Check notifications permission\n    if ('Notification' in window) {\n      setNotificationsEnabled(Notification.permission === 'granted')\n    }\n\n    // Register service worker only in production\n    if ('serviceWorker' in navigator && process.env.NODE_ENV === 'production') {\n      navigator.serviceWorker.register('/sw.js')\n        .then((registration) => {\n          // Check for updates\n          registration.addEventListener('updatefound', () => {\n            const newWorker = registration.installing\n            if (newWorker) {\n              newWorker.addEventListener('statechange', () => {\n                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n                  // New version available\n                  if (confirm('Nova versao disponivel. Atualizar agora?')) {\n                    window.location.reload()\n                  }\n                }\n              })\n            }\n          })\n        })\n        .catch((error) => {\n          // Silently fail in development/preview environments\n          console.log('[PWA] Service worker registration skipped:', error.message)\n        })\n    }\n\n    return () => {\n      window.removeEventListener('online', handleOnline)\n      window.removeEventListener('offline', handleOffline)\n      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt)\n      window.removeEventListener('appinstalled', handleAppInstalled)\n    }\n  }, [])\n\n  const installApp = async () => {\n    if (!deferredPrompt) return\n\n    deferredPrompt.prompt()\n    const { outcome } = await deferredPrompt.userChoice\n\n    if (outcome === 'accepted') {\n      setIsInstalled(true)\n    }\n\n    setDeferredPrompt(null)\n    setIsInstallable(false)\n  }\n\n  const enableNotifications = async (): Promise<boolean> => {\n    if (!('Notification' in window)) return false\n\n    const permission = await Notification.requestPermission()\n    const enabled = permission === 'granted'\n    setNotificationsEnabled(enabled)\n\n    if (enabled && 'serviceWorker' in navigator) {\n      try {\n        const registration = await navigator.serviceWorker.ready\n        // Subscribe to push notifications only if VAPID key is configured\n        const vapidKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY\n        if (vapidKey) {\n          await registration.pushManager.subscribe({\n            userVisibleOnly: true,\n            applicationServerKey: vapidKey,\n          })\n        }\n      } catch (error) {\n        console.error('Failed to subscribe to push notifications:', error)\n      }\n    }\n\n    return enabled\n  }\n\n  const disableNotifications = () => {\n    setNotificationsEnabled(false)\n    // Note: Cannot programmatically revoke notification permission\n  }\n\n  return (\n    <PWAContext.Provider\n      value={{\n        isInstallable,\n        isInstalled,\n        isOnline,\n        notificationsEnabled,\n        installApp,\n        enableNotifications,\n        disableNotifications,\n      }}\n    >\n      {children}\n    </PWAContext.Provider>\n  )\n}\n\nexport function usePWA() {\n  const context = useContext(PWAContext)\n  if (context === undefined) {\n    throw new Error('usePWA must be used within a PWAProvider')\n  }\n  return context\n}\n\n// Type for beforeinstallprompt event\ninterface BeforeInstallPromptEvent extends Event {\n  prompt: () => Promise<void>\n  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>\n}\n"],"names":[],"mappings":";;;;;;AA8DwC;;AA5DxC;;;AAFA;;AAcA,MAAM,2BAAa,IAAA,8KAAa,EAA6B;AAEtD,SAAS,YAAY,EAAE,QAAQ,EAA2B;;IAC/D,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAC;IACnD,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAC;IAC/C,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAC;IACzC,MAAM,CAAC,sBAAsB,wBAAwB,GAAG,IAAA,yKAAQ,EAAC;IACjE,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,yKAAQ,EAAkC;IAEtF,IAAA,0KAAS;iCAAC;YACR,6BAA6B;YAC7B,IAAI,OAAO,UAAU,CAAC,8BAA8B,OAAO,EAAE;gBAC3D,eAAe;YACjB;YAEA,sBAAsB;YACtB,YAAY,UAAU,MAAM;YAE5B,MAAM;sDAAe,IAAM,YAAY;;YACvC,MAAM;uDAAgB,IAAM,YAAY;;YAExC,OAAO,gBAAgB,CAAC,UAAU;YAClC,OAAO,gBAAgB,CAAC,WAAW;YAEnC,4BAA4B;YAC5B,MAAM;mEAA4B,CAAC;oBACjC,EAAE,cAAc;oBAChB,kBAAkB;oBAClB,iBAAiB;gBACnB;;YAEA,OAAO,gBAAgB,CAAC,uBAAuB;YAE/C,2BAA2B;YAC3B,MAAM;4DAAqB;oBACzB,eAAe;oBACf,iBAAiB;oBACjB,kBAAkB;gBACpB;;YAEA,OAAO,gBAAgB,CAAC,gBAAgB;YAExC,iCAAiC;YACjC,IAAI,kBAAkB,QAAQ;gBAC5B,wBAAwB,aAAa,UAAU,KAAK;YACtD;YAEA,6CAA6C;YAC7C,IAAI,mBAAmB,aAAa,oDAAyB;;YAwB7D;yCAAO;oBACL,OAAO,mBAAmB,CAAC,UAAU;oBACrC,OAAO,mBAAmB,CAAC,WAAW;oBACtC,OAAO,mBAAmB,CAAC,uBAAuB;oBAClD,OAAO,mBAAmB,CAAC,gBAAgB;gBAC7C;;QACF;gCAAG,EAAE;IAEL,MAAM,aAAa;QACjB,IAAI,CAAC,gBAAgB;QAErB,eAAe,MAAM;QACrB,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,eAAe,UAAU;QAEnD,IAAI,YAAY,YAAY;YAC1B,eAAe;QACjB;QAEA,kBAAkB;QAClB,iBAAiB;IACnB;IAEA,MAAM,sBAAsB;QAC1B,IAAI,CAAC,CAAC,kBAAkB,MAAM,GAAG,OAAO;QAExC,MAAM,aAAa,MAAM,aAAa,iBAAiB;QACvD,MAAM,UAAU,eAAe;QAC/B,wBAAwB;QAExB,IAAI,WAAW,mBAAmB,WAAW;YAC3C,IAAI;gBACF,MAAM,eAAe,MAAM,UAAU,aAAa,CAAC,KAAK;gBACxD,kEAAkE;gBAClE,MAAM;gBACN,wCAAc;oBACZ,MAAM,aAAa,WAAW,CAAC,SAAS,CAAC;wBACvC,iBAAiB;wBACjB,sBAAsB;oBACxB;gBACF;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,8CAA8C;YAC9D;QACF;QAEA,OAAO;IACT;IAEA,MAAM,uBAAuB;QAC3B,wBAAwB;IACxB,+DAA+D;IACjE;IAEA,qBACE,6LAAC,WAAW,QAAQ;QAClB,OAAO;YACL;YACA;YACA;YACA;YACA;YACA;YACA;QACF;kBAEC;;;;;;AAGP;GA1IgB;KAAA;AA4IT,SAAS;;IACd,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB"}}]
}